{% extends "base.html" %}

{% block title %}TradingBot — Backtest{% endblock %}
{% block page_title %}TradingBot — Backtest{% endblock %}

{% set active_page = 'backtest' %}

{% block extra_styles %}
  /* Metric cards */
  .metric-card {
    background: var(--table-row);
    border: 1px solid var(--panel-border);
    padding: 1rem;
    border-radius: 0.5rem;
  }
  .metric-label {
    color: var(--text-muted);
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .metric-value {
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 0.25rem;
    color: var(--text);
  }

  /* Loading spinner */
  .spinner-border { border-color: var(--blue); border-right-color: transparent; }

  /* Badges */
  .badge-up   { background: #062a1a; color: var(--text); border: 1px solid var(--green); }
  .badge-down { background: #2c0b0b; color: var(--text); border: 1px solid var(--red); }
{% endblock %}

{% block content %}
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <div class="row">
    <!-- Left: Configuration -->
    <div class="col-lg-4">
      <div class="card mb-3">
        <div class="card-body">
          <h2 class="h5 section-title mb-3">Configuration</h2>

          <form id="backtestForm">
            <div class="mb-3">
              <label for="strategy" class="form-label">Strategy</label>
              <select class="form-select" id="strategy" required>
                <option value="">Select strategy...</option>
                <option value="MeanReversion">Mean Reversion</option>
                <option value="Breakout">Breakout</option>
                <option value="TrendFollow">Trend Following</option>
              </select>
            </div>

            <div class="mb-3">
              <label for="symbol" class="form-label">Symbol</label>
              <select class="form-select" id="symbol" required>
                <option value="BTC_USDT">BTC_USDT</option>
                <option value="ETH_USDT">ETH_USDT</option>
                <option value="SOL_USDT">SOL_USDT</option>
              </select>
            </div>

            <div class="mb-3">
              <label for="timeframe" class="form-label">Timeframe</label>
              <select class="form-select" id="timeframe" required>
                <option value="1m">1 minute</option>
                <option value="5m" selected>5 minutes</option>
                <option value="15m">15 minutes</option>
                <option value="30m">30 minutes</option>
                <option value="1h">1 hour</option>
                <option value="4h">4 hours</option>
                <option value="1d">1 day</option>
              </select>
              <div class="form-text small" id="timeframeHelp">
                Available: ~3.5 days of data (1000 bars max)
              </div>
            </div>

            <div class="mb-3">
              <label for="days" class="form-label">History (days)</label>
              <input type="number" class="form-control" id="days" value="3" min="1" required>
              <div class="form-text small">
                Will use available cached data (see Data page)
              </div>
            </div>

            <div id="paramsSection" class="mb-3">
              <label class="form-label">Strategy Parameters</label>
              <div id="paramsInputs" class="text-muted small">
                Select a strategy to see parameters
              </div>
            </div>

            <div class="mb-3">
              <label for="initialCapital" class="form-label">Initial Capital ($)</label>
              <input type="number" class="form-control" id="initialCapital" value="1000" min="100" step="100" required>
            </div>

            <div class="mb-3">
              <label for="minNotional" class="form-label">Min Trade Size ($)</label>
              <input type="number" class="form-control" id="minNotional" value="100" min="10" step="10" required>
            </div>

            <!-- Validation warnings -->
            <div id="configWarning" class="alert alert-warning p-2 mb-2 small" style="display: none;">
              <strong>⚠️ Warning:</strong>
              <div id="configWarningText"></div>
            </div>

            <button type="submit" class="btn btn-primary w-100 mb-2" id="runBtn">
              Run Backtest
            </button>

            <!-- Active strategy indicator -->
            <div id="activeStrategyIndicator" class="alert alert-info p-2 mb-2 small" style="display: none;">
              <div class="d-flex align-items-center justify-content-between">
                <div>
                  <strong>Editing:</strong> <span id="activeStrategyName"></span>
                  <span class="badge bg-secondary ms-1">auto-save</span>
                </div>
                <button type="button" class="btn btn-sm btn-link p-0 text-decoration-none" onclick="newStrategy()" title="Start new configuration">
                  ✕
                </button>
              </div>
            </div>

            <!-- Action buttons -->
            <div class="d-flex gap-2">
              <button type="button" class="btn btn-outline-primary flex-grow-1" onclick="cloneStrategy()">
                Clone
              </button>
              <button type="button" class="btn btn-outline-primary flex-grow-1" onclick="newStrategy()">
                New
              </button>
            </div>
          </form>
        </div>
      </div>

      <!-- Saved & Quick Strategies -->
      <div class="card">
        <div class="card-body">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h2 class="h6 section-title mb-0">Strategies</h2>
            <button class="btn btn-sm btn-outline-light" onclick="loadSavedStrategies()">
              <svg width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                <path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41zm-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9z"/>
                <path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5.002 5.002 0 0 0 8 3zM3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9H3.1z"/>
              </svg>
            </button>
          </div>

          <!-- Saved strategies -->
          <div id="savedStrategies" class="d-grid gap-2">
            <!-- Populated by JavaScript -->
          </div>
        </div>
      </div>
    </div>

    <!-- Right: Results -->
    <div class="col-lg-8">
      <!-- Loading state -->
      <div id="loadingState" class="card text-center py-5" style="display: none;">
        <div class="card-body">
          <div class="spinner-border mb-3" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="text-muted">Running backtest...</p>
        </div>
      </div>

      <!-- Empty state -->
      <div id="emptyState" class="card text-center py-5">
        <div class="card-body">
          <p class="text-muted mb-0">Configure and run a backtest to see results</p>
        </div>
      </div>

      <!-- Results -->
      <div id="resultsContainer" style="display: none;">
        <!-- Metrics Grid -->
        <div class="row g-3 mb-3">
          <div class="col-md-3">
            <div class="metric-card">
              <div class="metric-label">Total Return</div>
              <div class="metric-value mono" id="metricReturn">-</div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="metric-card">
              <div class="metric-label">Sharpe Ratio</div>
              <div class="metric-value mono" id="metricSharpe">-</div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="metric-card">
              <div class="metric-label">Max Drawdown</div>
              <div class="metric-value mono" id="metricDrawdown">-</div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="metric-card">
              <div class="metric-label">Win Rate</div>
              <div class="metric-value mono" id="metricWinRate">-</div>
            </div>
          </div>
        </div>

        <!-- Tabs -->
        <div class="card">
          <div class="card-body">
            <ul class="nav nav-tabs mb-3" role="tablist">
              <li class="nav-item">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#equityTab">Equity Curve</button>
              </li>
              <li class="nav-item">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#metricsTab">All Metrics</button>
              </li>
              <li class="nav-item">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#tradesTab">Trades</button>
              </li>
            </ul>

            <div class="tab-content">
              <!-- Equity Curve -->
              <div class="tab-pane fade show active" id="equityTab">
                <canvas id="equityChart" style="height: 500px;"></canvas>
              </div>

              <!-- All Metrics -->
              <div class="tab-pane fade" id="metricsTab">
                <div class="row g-3">
                  <div class="col-md-6">
                    <table class="table table-sm table-dark">
                      <tbody id="metricsTable1"></tbody>
                    </table>
                  </div>
                  <div class="col-md-6">
                    <table class="table table-sm table-dark">
                      <tbody id="metricsTable2"></tbody>
                    </table>
                  </div>
                </div>
              </div>

              <!-- Trades -->
              <div class="tab-pane fade" id="tradesTab">
                <div class="table-responsive">
                  <table class="table table-sm table-dark table-striped">
                    <thead>
                      <tr>
                        <th>Time</th>
                        <th>Side</th>
                        <th>Qty</th>
                        <th>Price</th>
                        <th>Notional</th>
                      </tr>
                    </thead>
                    <tbody id="tradesTable"></tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
{% endblock %}

{% block scripts %}
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    let equityChart = null;

    // Active strategy tracking for auto-save
    let activeStrategyId = null;
    let activeStrategyName = null;
    let autoSaveTimeout = null;

    // Strategy parameters configuration
    const strategyParams = {
      MeanReversion: [
        { name: 'lookback', label: 'Lookback Period', type: 'number', default: 50, min: 10, max: 200 },
        { name: 'band', label: 'Band Multiplier', type: 'number', default: 2.0, min: 0.5, max: 5, step: 0.1 },
        { name: 'confirm_bars', label: 'Confirmation Bars', type: 'number', default: 2, min: 1, max: 5 }
      ],
      Breakout: [
        { name: 'lookback', label: 'Lookback Period', type: 'number', default: 60, min: 10, max: 200 },
        { name: 'confirm_bars', label: 'Confirmation Bars', type: 'number', default: 2, min: 1, max: 5 }
      ],
      TrendFollow: [
        { name: 'fast', label: 'Fast MA Period', type: 'number', default: 20, min: 5, max: 100 },
        { name: 'slow', label: 'Slow MA Period', type: 'number', default: 100, min: 20, max: 300 },
        { name: 'confirm_bars', label: 'Confirmation Bars', type: 'number', default: 2, min: 1, max: 5 }
      ]
    };

    // Update parameter inputs when strategy changes
    document.getElementById('strategy').addEventListener('change', (e) => {
      const strategy = e.target.value;
      const container = document.getElementById('paramsInputs');

      if (!strategy || !strategyParams[strategy]) {
        container.innerHTML = '<div class="text-muted small">Select a strategy to see parameters</div>';
        updateConfigWarnings();
        return;
      }

      const params = strategyParams[strategy];
      container.innerHTML = params.map(p => `
        <div class="mb-2">
          <label for="param_${p.name}" class="form-label small">${p.label}</label>
          <input
            type="${p.type}"
            class="form-control form-control-sm"
            id="param_${p.name}"
            name="${p.name}"
            value="${p.default}"
            ${p.min !== undefined ? `min="${p.min}"` : ''}
            ${p.max !== undefined ? `max="${p.max}"` : ''}
            ${p.step !== undefined ? `step="${p.step}"` : ''}
            required
          />
        </div>
      `).join('');

      // Update warnings after parameters are created
      updateConfigWarnings();
    });

    // Update timeframe help text and recommended days
    const timeframeLimits = {
      '1m': { days: 0.7, label: '~16 hours' },
      '5m': { days: 3, label: '~3.5 days' },
      '15m': { days: 10, label: '~10 days' },
      '30m': { days: 20, label: '~20 days' },
      '1h': { days: 40, label: '~41 days' },
      '4h': { days: 160, label: '~160 days' },
      '1d': { days: 1000, label: '~2.7 years' }
    };

    document.getElementById('timeframe').addEventListener('change', (e) => {
      const tf = e.target.value;
      const limit = timeframeLimits[tf];
      if (limit) {
        document.getElementById('timeframeHelp').textContent =
          `Available: ${limit.label} of data (1000 bars max)`;
        document.getElementById('days').value = Math.floor(limit.days);
      }
    });

    // Validate backtest configuration
    function validateBacktestConfig(strategy, params, timeframe, days) {
      const warnings = [];

      // Calculate how many bars we'll actually get
      const barsPerDay = {
        '1m': 1440,
        '5m': 288,
        '15m': 96,
        '30m': 48,
        '1h': 24,
        '4h': 6,
        '1d': 1
      };

      const expectedBars = days * (barsPerDay[timeframe] || 1);

      // Check if lookback period exceeds available data
      if (params.lookback) {
        const minDaysNeeded = Math.ceil((params.lookback + 50) / barsPerDay[timeframe]);

        if (params.lookback >= expectedBars * 0.9) {
          warnings.push(
            `⚠️ Lookback period (${params.lookback}) is too large for ${days} days of ${timeframe} data.\n` +
            `This will generate very few or no trades.\n\n` +
            `Recommended: Use at least ${minDaysNeeded} days of history.`
          );
        } else if (params.lookback >= expectedBars * 0.5) {
          warnings.push(
            `⚠️ Lookback period (${params.lookback}) uses ${Math.round(params.lookback/expectedBars*100)}% of available data.\n` +
            `This may generate limited trades.\n\n` +
            `Recommended: Use at least ${minDaysNeeded} days of history for better results.`
          );
        }
      }

      // Check for slow MA in trend following
      if (strategy === 'TrendFollow' && params.slow) {
        const minDaysNeeded = Math.ceil((params.slow + 50) / barsPerDay[timeframe]);

        if (params.slow >= expectedBars * 0.9) {
          warnings.push(
            `⚠️ Slow MA period (${params.slow}) is too large for ${days} days of ${timeframe} data.\n\n` +
            `Recommended: Use at least ${minDaysNeeded} days of history.`
          );
        }
      }

      // Check if we have enough bars for any meaningful backtest
      if (expectedBars < 100) {
        warnings.push(
          `⚠️ Only ${expectedBars} bars available with ${days} days of ${timeframe} data.\n` +
          `This is very limited for backtesting.\n\n` +
          `Recommended: Use more days or a longer timeframe.`
        );
      }

      return {
        valid: warnings.length === 0,
        warning: warnings.join('\n\n')
      };
    }

    // Form submission
    document.getElementById('backtestForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const strategy = document.getElementById('strategy').value;
      const symbol = document.getElementById('symbol').value;
      const timeframe = document.getElementById('timeframe').value;
      const days = parseInt(document.getElementById('days').value);
      const initialCapital = parseFloat(document.getElementById('initialCapital').value);
      const minNotional = parseFloat(document.getElementById('minNotional').value);

      // Collect strategy parameters
      const params = {};
      const paramInputs = document.querySelectorAll('#paramsInputs input');
      paramInputs.forEach(input => {
        const value = input.type === 'number' ? parseFloat(input.value) : input.value;
        params[input.name] = value;
      });

      // Validation: check if configuration makes sense
      const validation = validateBacktestConfig(strategy, params, timeframe, days);
      if (!validation.valid) {
        const proceed = confirm(validation.warning + '\n\nDo you want to proceed anyway?');
        if (!proceed) return;
      }

      // Show loading state
      document.getElementById('emptyState').style.display = 'none';
      document.getElementById('resultsContainer').style.display = 'none';
      document.getElementById('loadingState').style.display = 'block';
      document.getElementById('runBtn').disabled = true;
      document.getElementById('runBtn').innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Running...';

      // Debug: log what we're sending
      const payload = {
        strategy,
        params,
        symbol,
        timeframe,
        days,
        initial_capital: initialCapital,
        min_notional: minNotional
      };
      console.log('Backtest request:', payload);

      try {
        const response = await fetch('/backtest', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Backtest failed');
        }

        displayResults(data);

      } catch (error) {
        alert('Error: ' + error.message);
        document.getElementById('emptyState').style.display = 'block';
      } finally {
        document.getElementById('loadingState').style.display = 'none';
        document.getElementById('runBtn').disabled = false;
        document.getElementById('runBtn').textContent = 'Run Backtest';
      }
    });

    function displayResults(data) {
      const { metrics, equity_curve, trades, config } = data;

      // Show results container
      document.getElementById('resultsContainer').style.display = 'block';

      // Update key metrics
      const isPositive = metrics.total_return >= 0;
      document.getElementById('metricReturn').innerHTML = `<span style="color: ${isPositive ? 'var(--green)' : 'var(--red)'}">
        ${metrics.total_return >= 0 ? '+' : ''}${metrics.total_return.toFixed(2)}%
      </span>`;

      const sharpeGood = metrics.sharpe_ratio >= 1.0;
      document.getElementById('metricSharpe').innerHTML = `<span style="color: ${sharpeGood ? 'var(--green)' : 'var(--text)'}">
        ${metrics.sharpe_ratio.toFixed(2)}
      </span>`;

      const ddGood = metrics.max_drawdown <= 15;
      document.getElementById('metricDrawdown').innerHTML = `<span style="color: ${ddGood ? 'var(--green)' : 'var(--red)'}">
        ${metrics.max_drawdown.toFixed(2)}%
      </span>`;

      const wrGood = metrics.win_rate >= 50;
      document.getElementById('metricWinRate').innerHTML = `<span style="color: ${wrGood ? 'var(--green)' : 'var(--text)'}">
        ${metrics.win_rate.toFixed(2)}%
      </span>`;

      // Populate all metrics tables
      const metrics1 = [
        ['Total Return', `${metrics.total_return >= 0 ? '+' : ''}${metrics.total_return.toFixed(2)}%`],
        ['Sharpe Ratio', metrics.sharpe_ratio.toFixed(2)],
        ['Max Drawdown', `${metrics.max_drawdown.toFixed(2)}%`],
        ['Win Rate', `${metrics.win_rate.toFixed(2)}%`],
        ['Profit Factor', metrics.profit_factor.toFixed(2)],
        ['Total Trades', metrics.total_trades],
        ['Days', Math.round(metrics.days)]
      ];

      const metrics2 = [
        ['Winning Trades', metrics.winning_trades],
        ['Losing Trades', metrics.losing_trades],
        ['Avg Win', `$${metrics.avg_win.toFixed(2)}`],
        ['Avg Loss', `$${metrics.avg_loss.toFixed(2)}`],
        ['Avg Trade', `$${metrics.avg_trade.toFixed(2)}`],
        ['Max Consec Losses', metrics.max_consecutive_losses],
        ['Final Equity', `$${metrics.final_equity.toFixed(2)}`]
      ];

      document.getElementById('metricsTable1').innerHTML = metrics1.map(([label, value]) =>
        `<tr><td class="text-muted">${label}</td><td class="mono text-end">${value}</td></tr>`
      ).join('');

      document.getElementById('metricsTable2').innerHTML = metrics2.map(([label, value]) =>
        `<tr><td class="text-muted">${label}</td><td class="mono text-end">${value}</td></tr>`
      ).join('');

      // Render equity curve chart
      renderEquityChart(equity_curve, config);

      // Render trades table
      document.getElementById('tradesTable').innerHTML = trades.map(t => `
        <tr>
          <td class="mono small">${new Date(t.ts * 1000).toLocaleString()}</td>
          <td><span class="badge ${t.side === 'buy' ? 'badge-up' : 'badge-down'}">${t.side.toUpperCase()}</span></td>
          <td class="mono">${t.qty.toFixed(6)}</td>
          <td class="mono">$${t.price.toFixed(2)}</td>
          <td class="mono">$${t.notional.toFixed(2)}</td>
        </tr>
      `).join('');
    }

    function formatSmartLabel(timestamp, index, allTimestamps) {
      const date = new Date(timestamp * 1000);
      const firstDate = new Date(allTimestamps[0] * 1000);
      const lastDate = new Date(allTimestamps[allTimestamps.length - 1] * 1000);
      const totalDays = (lastDate - firstDate) / (1000 * 60 * 60 * 24);

      // For first label, always show date and time
      if (index === 0) {
        if (totalDays < 1) {
          return date.toLocaleString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
        }
        return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
      }

      // Less than 1 day: show times only
      if (totalDays < 1) {
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }

      // 1-3 days: show date when day changes, otherwise time
      if (totalDays <= 3) {
        const prevDate = new Date(allTimestamps[index - 1] * 1000);
        if (date.getDate() !== prevDate.getDate()) {
          return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
        }
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }

      // More than 3 days: show dates only
      return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
    }

    function renderEquityChart(equityCurve, config) {
      const ctx = document.getElementById('equityChart');

      // Destroy previous chart if exists
      if (equityChart) {
        equityChart.destroy();
      }

      const timestamps = equityCurve.map(p => p.ts);
      const labels = timestamps.map((ts, idx) => formatSmartLabel(ts, idx, timestamps));

      // Calculate actual time range from data
      const firstDate = new Date(timestamps[0] * 1000);
      const lastDate = new Date(timestamps[timestamps.length - 1] * 1000);
      const actualDays = Math.round((lastDate - firstDate) / (1000 * 60 * 60 * 24));

      // Format time range for title
      let timeRange;
      if (actualDays < 1) {
        const hours = Math.round((lastDate - firstDate) / (1000 * 60 * 60));
        timeRange = `${hours}h`;
      } else if (actualDays === 1) {
        timeRange = '1 day';
      } else {
        timeRange = `${actualDays} days`;
      }

      equityChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Equity',
            data: equityCurve.map(p => p.equity),
            borderColor: 'rgb(59, 130, 246)',
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.1,
            pointRadius: 0,
            pointHoverRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            title: {
              display: true,
              text: `${config.strategy} • ${config.symbol} • ${config.timeframe} • ${timeRange}`,
              color: 'rgb(232, 237, 243)',
              padding: 16,
              font: { size: 14 }
            },
            tooltip: {
              callbacks: {
                title: (items) => {
                  const idx = items[0].dataIndex;
                  const ts = timestamps[idx];
                  return new Date(ts * 1000).toLocaleString();
                },
                label: (context) => `Equity: $${context.parsed.y.toFixed(2)}`
              }
            }
          },
          scales: {
            x: {
              display: true,
              ticks: {
                maxTicksLimit: 12,
                color: 'rgb(183, 194, 207)',
                maxRotation: 45,
                minRotation: 0
              },
              grid: {
                color: 'rgba(36, 48, 65, 0.5)',
                drawOnChartArea: true,
                drawTicks: true
              }
            },
            y: {
              display: true,
              ticks: {
                color: 'rgb(183, 194, 207)',
                callback: (value) => '$' + value.toFixed(0)
              },
              grid: { color: 'rgba(36, 48, 65, 0.5)' }
            }
          },
          interaction: {
            intersect: false,
            mode: 'index'
          }
        }
      });
    }

    function loadConfig(config) {
      document.getElementById('strategy').value = config.strategy;
      document.getElementById('strategy').dispatchEvent(new Event('change'));

      setTimeout(() => {
        document.getElementById('symbol').value = config.symbol;
        document.getElementById('timeframe').value = config.timeframe;
        if (config.days) document.getElementById('days').value = config.days;
        if (config.initial_capital) document.getElementById('initialCapital').value = config.initial_capital;
        if (config.min_notional) document.getElementById('minNotional').value = config.min_notional;

        Object.entries(config.params).forEach(([key, value]) => {
          const input = document.getElementById(`param_${key}`);
          if (input) input.value = value;
        });

        // Update warnings after loading config
        updateConfigWarnings();
      }, 100);
    }

    async function loadSavedStrategies() {
      try {
        const res = await fetch('/backtest/saved');
        const data = await res.json();
        renderSavedStrategies(data.saved || []);
      } catch (e) {
        console.error('Failed to load saved strategies:', e);
      }
    }

    function renderSavedStrategies(saved) {
      const container = document.getElementById('savedStrategies');

      if (saved.length === 0) {
        container.innerHTML = '<div class="small text-muted">No saved strategies yet. Configure a strategy below and click "Clone" to save it.</div>';
        return;
      }

      container.innerHTML = saved.map(s => `
        <div class="d-flex align-items-center gap-2">
          <button class="btn btn-sm btn-outline-light text-start flex-grow-1" onclick='loadSavedConfig(${JSON.stringify(s)})'>
            <strong>${s.name}</strong><br>
            <span class="small text-muted">${s.strategy} • ${s.symbol} • ${s.timeframe}</span>
          </button>
          <button class="btn btn-sm btn-outline-danger" onclick="deleteSavedStrategy(${s.id})" title="Delete">
            <svg width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
              <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
              <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
            </svg>
          </button>
        </div>
      `).join('');
    }

    function loadSavedConfig(saved) {
      // Set as active strategy for auto-save
      activeStrategyId = saved.id;
      activeStrategyName = saved.name;

      // Show active indicator
      document.getElementById('activeStrategyName').textContent = saved.name;
      document.getElementById('activeStrategyIndicator').style.display = 'block';

      loadConfig(saved);
    }

    // Auto-save with debouncing (saves after 1 second of no changes)
    function autoSave() {
      // Only auto-save if we have an active strategy
      if (!activeStrategyId || !activeStrategyName) return;

      const strategy = document.getElementById('strategy').value;
      if (!strategy) return;

      // Clear existing timeout
      if (autoSaveTimeout) {
        clearTimeout(autoSaveTimeout);
      }

      // Debounce: save after 1 second of no changes
      autoSaveTimeout = setTimeout(async () => {
        // Collect current config
        const params = {};
        const paramInputs = document.querySelectorAll('#paramsInputs input');
        paramInputs.forEach(input => {
          const value = input.type === 'number' ? parseFloat(input.value) : input.value;
          params[input.name] = value;
        });

        const config = {
          name: activeStrategyName,
          strategy: strategy,
          symbol: document.getElementById('symbol').value,
          timeframe: document.getElementById('timeframe').value,
          params: params,
          initial_capital: parseFloat(document.getElementById('initialCapital').value),
          min_notional: parseFloat(document.getElementById('minNotional').value),
        };

        try {
          await fetch('/backtest/saved', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(config)
          });
          // Silent save - don't show alerts
        } catch (e) {
          console.error('Auto-save failed:', e);
        }
      }, 1000);
    }

    async function cloneStrategy() {
      const strategy = document.getElementById('strategy').value;
      if (!strategy) {
        alert('Please configure a strategy first');
        return;
      }

      const name = prompt('Enter a name for the cloned configuration:');
      if (!name) return;

      // Collect current config
      const params = {};
      const paramInputs = document.querySelectorAll('#paramsInputs input');
      paramInputs.forEach(input => {
        const value = input.type === 'number' ? parseFloat(input.value) : input.value;
        params[input.name] = value;
      });

      const config = {
        name: name,
        strategy: strategy,
        symbol: document.getElementById('symbol').value,
        timeframe: document.getElementById('timeframe').value,
        params: params,
        initial_capital: parseFloat(document.getElementById('initialCapital').value),
        min_notional: parseFloat(document.getElementById('minNotional').value),
      };

      try {
        const res = await fetch('/backtest/saved', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(config)
        });

        const data = await res.json();
        if (data.error) {
          alert('Error cloning: ' + data.error);
        } else {
          // Set the clone as the new active strategy
          activeStrategyId = data.id;
          activeStrategyName = name;
          document.getElementById('activeStrategyName').textContent = name;
          document.getElementById('activeStrategyIndicator').style.display = 'block';

          // Refresh the saved strategies list
          loadSavedStrategies();
        }
      } catch (e) {
        alert('Error cloning: ' + e.message);
      }
    }

    function newStrategy() {
      // Clear active strategy
      activeStrategyId = null;
      activeStrategyName = null;
      document.getElementById('activeStrategyIndicator').style.display = 'none';

      // Reset form to defaults
      document.getElementById('strategy').value = '';
      document.getElementById('symbol').value = 'BTC_USDT';
      document.getElementById('timeframe').value = '5m';
      document.getElementById('days').value = '3';
      document.getElementById('initialCapital').value = '1000';
      document.getElementById('minNotional').value = '100';
      document.getElementById('paramsInputs').innerHTML = '<div class="text-muted small">Select a strategy to see parameters</div>';
    }

    async function deleteSavedStrategy(id) {
      if (!confirm('Delete this saved strategy?')) return;

      try {
        const res = await fetch(`/backtest/saved/${id}`, { method: 'DELETE' });
        const data = await res.json();

        if (data.deleted) {
          loadSavedStrategies();
        } else {
          alert('Error deleting: ' + (data.error || 'Unknown error'));
        }
      } catch (e) {
        alert('Error deleting: ' + e.message);
      }
    }

    // Check and update configuration warnings in real-time
    function updateConfigWarnings() {
      const strategy = document.getElementById('strategy').value;
      const timeframe = document.getElementById('timeframe').value;
      const days = parseInt(document.getElementById('days').value) || 0;

      if (!strategy) {
        document.getElementById('configWarning').style.display = 'none';
        return;
      }

      // Collect current parameters
      const params = {};
      const paramInputs = document.querySelectorAll('#paramsInputs input');
      paramInputs.forEach(input => {
        const value = input.type === 'number' ? parseFloat(input.value) : input.value;
        params[input.name] = value;
      });

      const validation = validateBacktestConfig(strategy, params, timeframe, days);

      if (!validation.valid) {
        document.getElementById('configWarningText').innerHTML = validation.warning.replace(/\n/g, '<br>');
        document.getElementById('configWarning').style.display = 'block';
      } else {
        document.getElementById('configWarning').style.display = 'none';
      }
    }

    // Add auto-save event listeners to all form inputs
    function setupAutoSave() {
      const formInputs = [
        'strategy', 'symbol', 'timeframe', 'days',
        'initialCapital', 'minNotional'
      ];

      formInputs.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.addEventListener('change', autoSave);
          element.addEventListener('change', updateConfigWarnings);
        }
      });

      // Also listen to parameter inputs (dynamically created)
      // Use event delegation on the parent container
      const paramsContainer = document.getElementById('paramsInputs');
      paramsContainer.addEventListener('input', autoSave);
      paramsContainer.addEventListener('input', updateConfigWarnings);
    }

    // Load saved strategies on page load
    loadSavedStrategies();

    // Set up auto-save listeners
    setupAutoSave();
  </script>
{% endblock %}
